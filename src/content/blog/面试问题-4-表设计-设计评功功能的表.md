---
title: "面试问题-表设计-设计评论功能的表"
description: "如何设计一个支持多级评论、点赞、回复的评论系统表结构"
pubDate: 2024-12-16
---

## 问题描述

我想要实现一个评论功能，
用户可以在某一篇文章下发表评论，评论有点赞数，其他人可以在评论下回复评论，形成评论树，
我该如何设计这个表结构？

最后我需要查询某篇文章下面的评论，需要显示一级评论和对应的二级评论，按照时间倒序，可以用一个SQL，也可以是多个SQL查询实现。
但需要尽量保证查询性能，也可以在设计表的进行冗余字段的设计，比如回复数量。

---

## 表结构设计

### 1. 用户表 (users)

```sql
CREATE TABLE users (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    username VARCHAR(50) NOT NULL,
    avatar VARCHAR(255),
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

### 2. 文章表 (articles)

```sql
CREATE TABLE articles (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(255) NOT NULL,
    content TEXT,
    user_id BIGINT NOT NULL,
    comment_count INT DEFAULT 0,  -- 冗余字段：评论总数
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_id (user_id)
);
```

### 3. 评论表 (comments) - 核心表

```sql
CREATE TABLE comments (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    article_id BIGINT NOT NULL,           -- 所属文章ID
    user_id BIGINT NOT NULL,              -- 评论者ID
    content TEXT NOT NULL,                -- 评论内容
    
    -- 层级关系字段
    parent_id BIGINT DEFAULT 0,           -- 父评论ID，0表示一级评论
    root_id BIGINT DEFAULT 0,             -- 根评论ID，0表示自己就是根评论
    reply_user_id BIGINT DEFAULT NULL,    -- 被回复的用户ID（用于@某人）
    
    -- 冗余统计字段
    like_count INT DEFAULT 0,             -- 点赞数
    reply_count INT DEFAULT 0,            -- 回复数（仅一级评论维护）
    
    -- 状态和时间
    status TINYINT DEFAULT 1,             -- 状态：1正常 0删除
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    
    -- 索引设计
    INDEX idx_article_id (article_id),
    INDEX idx_parent_id (parent_id),
    INDEX idx_root_id (root_id),
    INDEX idx_user_id (user_id),
    INDEX idx_article_created (article_id, created_at)  -- 复合索引，用于分页查询
);
```

### 4. 评论点赞表 (comment_likes)

```sql
CREATE TABLE comment_likes (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    comment_id BIGINT NOT NULL,
    user_id BIGINT NOT NULL,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    
    UNIQUE INDEX idx_comment_user (comment_id, user_id),  -- 防止重复点赞
    INDEX idx_user_id (user_id)
);
```

---

## 字段设计说明

### 为什么需要 `root_id` 和 `parent_id` 两个字段？

| 字段 | 作用 |
|------|------|
| `parent_id` | 指向直接父评论，用于构建完整的评论树层级关系 |
| `root_id` | 指向一级评论（根评论），方便快速查询某个一级评论下的所有回复 |

**示例场景：**
```
一级评论A (id=1, parent_id=0, root_id=0)
  └── 二级评论B (id=2, parent_id=1, root_id=1)  -- 回复A
       └── 三级评论C (id=3, parent_id=2, root_id=1)  -- 回复B
```

有了 `root_id`，查询一级评论A的所有回复只需：
```sql
SELECT * FROM comments WHERE root_id = 1;
```

### 为什么需要 `reply_user_id`？

用于显示 "张三 回复 李四：xxx" 这样的效果，记录被回复者的用户ID。

---

## 查询方案

### 方案一：两次查询（推荐）

**第一步：查询一级评论（分页）**

```sql
SELECT 
    c.id,
    c.content,
    c.like_count,
    c.reply_count,
    c.created_at,
    u.id AS user_id,
    u.username,
    u.avatar
FROM comments c
LEFT JOIN users u ON c.user_id = u.id
WHERE c.article_id = ? 
  AND c.parent_id = 0 
  AND c.status = 1
ORDER BY c.created_at DESC
LIMIT ?, ?;
```

**第二步：查询二级评论（根据一级评论ID批量查询）**

```sql
SELECT 
    c.id,
    c.root_id,
    c.parent_id,
    c.content,
    c.like_count,
    c.created_at,
    u.id AS user_id,
    u.username,
    u.avatar,
    ru.id AS reply_user_id,
    ru.username AS reply_username
FROM comments c
LEFT JOIN users u ON c.user_id = u.id
LEFT JOIN users ru ON c.reply_user_id = ru.id
WHERE c.root_id IN (?, ?, ?, ...)  -- 传入一级评论的ID列表
  AND c.status = 1
ORDER BY c.created_at ASC
LIMIT 10;  -- 所有二级评论加起来只取前10条


SELECT * FROM (
    SELECT 
        c.id,
        c.root_id,
        c.parent_id,
        c.content,
        c.like_count,
        c.created_at,
        u.id AS user_id,
        u.username,
        u.avatar,
        ru.id AS reply_user_id,
        ru.username AS reply_username,
        ROW_NUMBER() OVER (PARTITION BY c.root_id ORDER BY c.created_at ASC) AS rn
    FROM comments c
    LEFT JOIN users u ON c.user_id = u.id
    LEFT JOIN users ru ON c.reply_user_id = ru.id
    WHERE c.root_id IN (?, ?, ?, ...)
      AND c.status = 1
) AS ranked
WHERE rn <= 10;  -- 每个一级评论下取前10条


-- 使用 LATERAL JOIN（MySQL 8.0.14+）
SELECT r.*
FROM (SELECT DISTINCT root_id FROM comments WHERE root_id IN (?, ?, ?)) AS roots
JOIN LATERAL (
    SELECT c.*, u.username, u.avatar, ru.username AS reply_username
    FROM comments c
    LEFT JOIN users u ON c.user_id = u.id
    LEFT JOIN users ru ON c.reply_user_id = ru.id
    WHERE c.root_id = roots.root_id AND c.status = 1
    ORDER BY c.created_at ASC
    LIMIT 10  -- 这里的 LIMIT 可以利用索引提前终止
) AS r ON TRUE;
```

### 性能对比

| 方案 | 扫描行数 | 适用场景 |
|------|----------|----------|
| ROW_NUMBER() 窗口函数 | 全部1000条 | 数据量小，SQL 简洁 |
| 代码层面处理 | 全部1000条 | 通用，逻辑清晰 |
| LATERAL JOIN | 每个 root_id 最多10条 | MySQL 8.0.14+，性能最优 |

### 方案二：单次查询（适合数据量小的场景）

```sql
SELECT 
    c.id,
    c.parent_id,
    c.root_id,
    c.content,
    c.like_count,
    c.reply_count,
    c.created_at,
    u.id AS user_id,
    u.username,
    u.avatar,
    ru.username AS reply_username
FROM comments c
LEFT JOIN users u ON c.user_id = u.id
LEFT JOIN users ru ON c.reply_user_id = ru.id
WHERE c.article_id = ?
  AND c.status = 1
  AND (c.parent_id = 0 OR c.root_id IN (
      SELECT id FROM (
          SELECT id FROM comments 
          WHERE article_id = ? AND parent_id = 0 AND status = 1
          ORDER BY created_at DESC
          LIMIT ?, ?
      ) AS temp
  ))
ORDER BY 
    CASE WHEN c.parent_id = 0 THEN c.created_at END DESC,
    c.root_id,
    c.created_at ASC;
```

---

## 代码层面的数据组装

### Python 示例

```python
def get_comments_with_replies(article_id: int, page: int, page_size: int):
    offset = (page - 1) * page_size
    
    # 1. 查询一级评论
    root_comments = db.execute("""
        SELECT id, content, like_count, reply_count, created_at, user_id
        FROM comments
        WHERE article_id = %s AND parent_id = 0 AND status = 1
        ORDER BY created_at DESC
        LIMIT %s, %s
    """, (article_id, offset, page_size))
    
    if not root_comments:
        return []
    
    root_ids = [c['id'] for c in root_comments]
    
    # 2. 批量查询二级评论
    replies = db.execute("""
        SELECT id, root_id, parent_id, content, like_count, created_at, 
               user_id, reply_user_id
        FROM comments
        WHERE root_id IN %s AND status = 1
        ORDER BY created_at ASC
    """, (tuple(root_ids),))
    
    # 3. 组装数据结构
    reply_map = {}
    for reply in replies:
        root_id = reply['root_id']
        if root_id not in reply_map:
            reply_map[root_id] = []
        reply_map[root_id].append(reply)
    
    # 4. 合并结果
    result = []
    for comment in root_comments:
        comment['replies'] = reply_map.get(comment['id'], [])
        result.append(comment)
    
    return result
```

---

## 性能优化建议

### 1. 索引优化

- `(article_id, created_at)` 复合索引用于文章评论的分页查询
- `(root_id)` 索引用于快速查询某一级评论下的所有回复
- `(comment_id, user_id)` 唯一索引用于点赞去重

### 2. 冗余字段

| 冗余字段 | 作用 | 更新时机 |
|---------|------|---------|
| `like_count` | 避免每次 COUNT 查询点赞数 | 点赞/取消点赞时更新 |
| `reply_count` | 避免每次 COUNT 查询回复数 | 新增/删除回复时更新 |
| `comment_count` | 文章的评论总数 | 新增/删除评论时更新 |

### 3. 缓存策略

```python
# 热门文章的评论可以使用 Redis 缓存
cache_key = f"article:{article_id}:comments:page:{page}"
cached = redis.get(cache_key)
if cached:
    return json.loads(cached)

# 查询数据库...
result = get_comments_with_replies(article_id, page, page_size)

# 缓存5分钟
redis.setex(cache_key, 300, json.dumps(result))
```

### 4. 分页策略

- **一级评论**：按时间倒序分页
- **二级评论**：默认展示前3-5条，点击"查看更多"时加载更多

---

## 扩展功能

### 评论层级限制

建议最多支持两级（一级评论 + 回复），超过两级的回复都归属到一级评论下，通过 `reply_user_id` 标记被回复者：

```
一级评论A
  ├── B 回复 A
  ├── C 回复 B（显示为：C 回复 @B：xxx）
  └── D 回复 C（显示为：D 回复 @C：xxx）
```

这种设计简化了查询逻辑，也是微博、抖音等主流平台的做法。

### 评论审核

可以在 `status` 字段扩展更多状态：
- 0：已删除
- 1：正常
- 2：待审核
- 3：审核不通过

---

## 总结

| 设计要点 | 说明 |
|---------|------|
| 使用 `parent_id` + `root_id` | 支持多级评论，同时方便查询 |
| 冗余统计字段 | 减少 COUNT 查询，提升性能 |
| 合理的索引设计 | 覆盖主要查询场景 |
| 两次查询策略 | 先查一级评论，再批量查二级评论 |
| 层级限制 | 建议最多两级，简化查询逻辑 |