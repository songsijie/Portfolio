---
title: "面试问题-算法：n个有序列表合并"
description: "n个有序列表合并成一个有序列表，时间复杂度最低的方案"
pubDate: 2024-12-16
tags: ["算法", "面试", "堆", "归并"]
---

# n个有序列表合并成一个有序列表

## 问题描述

给定 n 个有序列表（升序），将它们合并成一个有序列表。这是一道经典的面试题，考察对时间复杂度的理解和算法优化能力。

## 解决方案

### 方案一：暴力合并（不推荐）

**思路**：将所有列表合并成一个列表，然后排序。

```python
def merge_lists_brute_force(lists):
    result = []
    for lst in lists:
        result.extend(lst)
    result.sort()
    return result
```

**时间复杂度**：O(N log N)，其中 N 是所有元素的总数。

**缺点**：没有利用"有序"这个条件，效率较低。

---

### 方案二：逐一合并（简单但非最优）

**思路**：依次将两个列表合并，直到只剩一个列表。

```python
def merge_two_lists(l1, l2):
    result = []
    i, j = 0, 0
    while i < len(l1) and j < len(l2):
        if l1[i] <= l2[j]:
            result.append(l1[i])
            i += 1
        else:
            result.append(l2[j])
            j += 1
    result.extend(l1[i:])
    result.extend(l2[j:])
    return result

def merge_lists_sequential(lists):
    if not lists:
        return []
    result = lists[0]
    for i in range(1, len(lists)):
        result = merge_two_lists(result, lists[i])
    return result
```

**时间复杂度**：O(n × N)，其中 n 是列表个数，N 是所有元素总数。

**缺点**：每次合并都需要遍历已合并的所有元素，效率不高。

---

### 方案三：分治归并（推荐）

**思路**：使用分治法，将 n 个列表两两配对合并，重复这个过程直到只剩一个列表。

```python
def merge_two_lists(l1, l2):
    result = []
    i, j = 0, 0
    while i < len(l1) and j < len(l2):
        if l1[i] <= l2[j]:
            result.append(l1[i])
            i += 1
        else:
            result.append(l2[j])
            j += 1
    result.extend(l1[i:])
    result.extend(l2[j:])
    return result

def merge_lists_divide_conquer(lists):
    if not lists:
        return []
    if len(lists) == 1:
        return lists[0]
    
    mid = len(lists) // 2
    left = merge_lists_divide_conquer(lists[:mid])
    right = merge_lists_divide_conquer(lists[mid:])
    return merge_two_lists(left, right)
```

**时间复杂度**：O(N log n)，其中 n 是列表个数，N 是所有元素总数。

**优点**：利用分治思想，减少了重复比较的次数。

---

### 方案四：最小堆（最优解）⭐

**思路**：使用最小堆（优先队列），每次从堆中取出最小元素，然后将该元素所在列表的下一个元素加入堆中。

```python
import heapq

def merge_lists_heap(lists):
    """
    使用最小堆合并n个有序列表
    时间复杂度: O(N log n)，N是总元素数，n是列表个数
    空间复杂度: O(n)，堆中最多存储n个元素
    """
    result = []
    heap = []
    
    # 初始化：将每个列表的第一个元素加入堆
    # 堆元素格式：(值, 列表索引, 元素在列表中的索引)
    for i, lst in enumerate(lists):
        if lst:  # 跳过空列表
            heapq.heappush(heap, (lst[0], i, 0))
    
    while heap:
        val, list_idx, elem_idx = heapq.heappop(heap)
        result.append(val)
        
        # 如果当前列表还有下一个元素，加入堆
        if elem_idx + 1 < len(lists[list_idx]):
            next_val = lists[list_idx][elem_idx + 1]
            heapq.heappush(heap, (next_val, list_idx, elem_idx + 1))
    
    return result
```

**时间复杂度**：O(N log n)
- 每个元素入堆和出堆各一次
- 堆操作的时间复杂度是 O(log n)（n 是列表个数）
- 总共 N 个元素，所以是 O(N log n)

**空间复杂度**：O(n)，堆中同时最多存储 n 个元素（每个列表一个）。

**优点**：
1. 充分利用了列表有序的特点
2. 堆的大小只与列表个数有关，而非元素总数
3. 时间和空间复杂度都是最优的

---

## 链表版本（LeetCode 23）

如果输入是链表形式，代码如下：

```python
import heapq
from typing import List, Optional

class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeKLists(lists: List[Optional[ListNode]]) -> Optional[ListNode]:
    heap = []
    
    # 初始化堆
    for i, node in enumerate(lists):
        if node:
            heapq.heappush(heap, (node.val, i, node))
    
    dummy = ListNode(0)
    curr = dummy
    
    while heap:
        val, idx, node = heapq.heappop(heap)
        curr.next = node
        curr = curr.next
        
        if node.next:
            heapq.heappush(heap, (node.next.val, idx, node.next))
    
    return dummy.next
```

---

## 方案对比

| 方案 | 时间复杂度 | 空间复杂度 | 说明 |
|------|-----------|-----------|------|
| 暴力合并 | O(N log N) | O(N) | 未利用有序性 |
| 逐一合并 | O(n × N) | O(N) | 重复遍历过多 |
| 分治归并 | O(N log n) | O(N) | 递归栈空间 |
| 最小堆 | O(N log n) | O(n) | **最优解** |

> 其中 n 是列表个数，N 是所有元素的总数

---

## 面试要点

1. **理解问题**：明确是 n 个有序列表合并，而不是两个列表合并
2. **最优方案**：最小堆或分治归并，时间复杂度都是 O(N log n)
3. **为什么用堆**：堆可以在 O(log n) 时间内找到 n 个元素中的最小值
4. **空间优化**：最小堆方案空间复杂度是 O(n)，优于分治的 O(N)
5. **边界情况**：处理空列表、单个列表等边界情况

---

## 相关题目

- LeetCode 21: 合并两个有序链表
- LeetCode 23: 合并K个升序链表
- LeetCode 88: 合并两个有序数组