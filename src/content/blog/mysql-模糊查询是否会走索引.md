---
title: "MySQL模糊查询是否会走索引？"
description: "深入分析MySQL模糊查询在不同场景下的索引使用情况，包括最左前缀匹配、覆盖索引、函数索引和全文索引等优化方案"
publishDate: 2025-10-22
tags: ["MySQL", "索引优化", "数据库", "性能优化", "面试"]
---

# MySQL模糊查询是否会走索引？

这是一个非常经典的面试题和性能优化点。答案是：**不一定，取决于模糊查询的具体写法。**

MySQL 的索引就像一本字典的目录，它是按照字段值的**从左到右的顺序**建立的。因此，只有当查询条件能够利用这个“从左到右”的顺序时，索引才能生效。

下面我们分情况详细讨论：

---

### 1. 走索引的情况

#### **情况一：最左前缀匹配（`like 'abc%'`）**

这是模糊查询中**唯一能有效利用索引**的情况。

*   **示例：** `SELECT * FROM users WHERE name LIKE '张%';`
*   **解释：** 这个查询是要查找所有以“张”开头的名字。因为索引 (`name` 索引) 也是按照 `'张三'`, `'张四'`, `'张三丰'`... 这样的顺序排列的，所以 MySQL 可以快速地在索引树中定位到第一个以“张”开头的记录，然后沿着叶子节点向后扫描，直到遇到不以“张”开头的记录为止。
*   **索引使用情况：** 通常使用 **索引范围扫描**。

你可以使用 `EXPLAIN` 命令来验证，在 `type` 列会看到 `range`，在 `key` 列会看到使用的索引名。

```sql
EXPLAIN SELECT * FROM users WHERE name LIKE '张%';
```

---

### 2. 不走索引的情况

#### **情况二：后缀匹配（`like '%abc'`）**

*   **示例：** `SELECT * FROM users WHERE name LIKE '%三';`
*   **解释：** 查询条件以通配符 `%` 开头，意味着“以任何字符结尾”。MySQL 无法知道哪些记录会以“三”结尾，因为它没有“从右到左”的索引。它必须对索引中的**每一条记录**进行全扫描，然后判断其是否以“三”结尾。这相当于全表扫描。
*   **索引使用情况：** **全索引扫描** 或 **全表扫描**。即使它扫描了整个索引，效率也非常低。

#### **情况三：前后模糊匹配（`like '%abc%'`）**

*   **示例：** `SELECT * FROM articles WHERE content LIKE '%数据库%';`
*   **解释：** 这和情况二类似。因为条件的两端都是不确定的，索引的顺序完全无法利用。MySQL 必须检查每一行数据，看看字段中是否包含“数据库”这个子串。
*   **索引使用情况：** **全索引扫描** 或 **全表扫描**。

---

### 特殊情况与优化方案

#### **1. 覆盖索引**

即使是在 `LIKE '%abc%'` 这种不走索引的情况下，如果你的查询**只查询了被索引覆盖的字段**，MySQL 有时也会选择扫描整个索引而不是全表，因为索引文件通常比数据文件小。这被称为“覆盖索引扫描”。

*   **示例：**
    ```sql
    -- 假设在 name 上建立了索引
    SELECT id, name FROM users WHERE name LIKE '%三%';
    ```
*   **解释：** `id` 和 `name` 都在索引里，所以 MySQL 可能会扫描整个 `name` 索引来找出结果，这比全表扫描稍微快一点。在 `EXPLAIN` 的 `Extra` 列你会看到 `Using index`。

#### **2. 函数索引（MySQL 8.0+）**

从 MySQL 8.0 开始，支持函数索引。这为解决后缀匹配问题提供了一个优雅的方案。

*   **场景：** 经常需要根据邮箱后缀查询 (`LIKE '%@qq.com'`)。
*   **优化：** 可以创建一个反向字段的函数索引。
    ```sql
    -- 添加一个反向字段的虚拟列
    ALTER TABLE users ADD COLUMN reverse_name VARCHAR(100) AS (REVERSE(name)) VIRTUAL;
    -- 为这个虚拟列创建索引
    CREATE INDEX idx_reverse_name ON users(reverse_name);

    -- 查询时，也使用反向逻辑
    SELECT * FROM users WHERE REVERSE(name) LIKE REVERSE('%@qq.com');
    -- 等价于：REVERSE(name) LIKE 'moc.qq@%'，这就变成了最左前缀匹配！
    ```

#### **3. 全文索引（最佳方案 for 全文搜索）**

如果你的需求是进行**文本内容的搜索**（包含词语、短语等），而不是简单的前缀匹配，那么 `LIKE` 是完全错误的选择。你应该使用 MySQL 内置的 **全文索引**。

*   **创建全文索引：**
    ```sql
    ALTER TABLE articles ADD FULLTEXT INDEX ft_idx_content (content);
    ```
*   **使用全文搜索：**
    ```sql
    SELECT * FROM articles WHERE MATCH(content) AGAINST('数据库' IN NATURAL LANGUAGE MODE);
    ```
*   **优点：** 全文索引是为这种场景设计的，效率远高于 `LIKE '%...%'`，并且支持分词、相关性排序等高级功能。

---

### 总结

| 模糊查询类型 | 示例 | 是否走索引 | 说明与建议 |
| :--- | :--- | :--- | :--- |
| **`LIKE 'abc%'`** | `LIKE '张%'` | **✅ 是** | **最佳实践**，利用索引的最左前缀原则。 |
| **`LIKE '%abc'`** | `LIKE '%三'` | **❌ 否** | 全表扫描。考虑使用 MySQL 8.0 的**函数索引**进行优化。 |
| **`LIKE '%abc%'`** | `LIKE '%代码%'` | **❌ 否** | 全表扫描。如果是搜索文本内容，强烈建议使用**全文索引**。 |

**核心思想：** 索引是一颗B+树，它的键值是按顺序存储的。只有当你的查询条件能够利用这个顺序（即从索引树的最左边开始匹配）时，索引才能被高效使用。一旦你使用了前导通配符 `%`，就破坏了这个顺序，导致索引失效。